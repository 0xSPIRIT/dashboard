# Chapter 6 -- Databases

We set up a database by going into vercel, adding one, and
linking it to our project. I used a postgres database called
Neon, and named the database 'cabinet'.

Now, I added all the .env stuff from vercel into my .env in
my project, linking them together. Now, whenever I make an
SQL query from my end, it will query that database through
the database keys in the .env file, which next automatically
reads. You can use them like variables;

    import postgres from 'postgres';
    
    const sql = postgres(process.env.POSTGRES_URL!, { ssl: 'require' });
    
    async function listInvoices() {
    	const data = await sql`
        SELECT invoices.amount, customers.name
        FROM invoices
        JOIN customers ON invoices.customer_id = customers.id
        WHERE invoices.amount = 666;
      `;
    
    	return data;
    }
    
    export async function GET() {
      try {
      	return Response.json(await listInvoices());
      } catch (error) {
      	return Response.json({ error }, { status: 500 });
      }
    }

We can use this since we're doing all our database stuff within this
server-side component which is a huge W. We don't need a separate
API layer to handle database accesses -- remember, we don't want
any of this stuff on the client's machine to protect our own
database keys & system in general.

## Refresher on Async

`async` functions return a Promise, which is an object that represents the
eventual completion of an asynchronous operation that resolves to its
resulting value.

To obtain the resulting value you can use `await`, which waits for the
asynchronous expression to resolve, pausing the operation of the current
function.

https://javascript.info/promise-basics

### Promises

A promise can be in 1 of 3 states:
  - Pending (not finished yet)
  - Fulfilled (finished successfully via `resolve`)
  - Rejected (finished with an error `reject`)

Once a promise is fulfilled or rejected, it's settled and cannot change.
It does not pause the current thread.

Example Code:
  const p = new Promise(resolve => setTimeout(() => {
      console.log("A");
      resolve(123)
  }, 1000));
  
  p.then(a => console.log(a))
  
  console.log("B");

Output:
  B
  A
  123

.then chains off a promise and executes the functions inside
when the promise has been resolved. You can handle both the
resolve and reject conditions from that promise:

  p.then(
    result => console.log("The promise p resolved successfully with " + p);
    error => alert(error);
  );

if the `result` function returns another promise, we can chain
another `.then` to it!

### useEffect(function, [deps])

This executes `function` whenever
  1) anything in `deps` changes, OR
  2) after the first render of the component.
